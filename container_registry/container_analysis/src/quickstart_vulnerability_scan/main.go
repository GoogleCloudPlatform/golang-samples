// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Sample quickstart for getting vulnerabilities from the Container Analysis API: https://cloud.google.com/container-registry/docs/vulnerability-scan-go
package main

import (
	"context"
	"flag"
	"fmt"
	"time"

	containeranalysis "cloud.google.com/go/containeranalysis/apiv1beta1"
	"google.golang.org/api/iterator"
	discovery "google.golang.org/genproto/googleapis/devtools/containeranalysis/v1beta1/discovery"
	grafeaspb "google.golang.org/genproto/googleapis/devtools/containeranalysis/v1beta1/grafeas"
	vulnerability "google.golang.org/genproto/googleapis/devtools/containeranalysis/v1beta1/vulnerability"
)

const (
	discoveryProviderID          = "goog-analysis"
	discoveryVulnerabilityNoteID = "PACKAGE_VULNERABILITY"
	backoff                      = time.Second
)

func main() {
	projectID := "my-project-id"                                           // The Google Cloud Platform project ID
	resourceURL := "https://gcr.io/my-project-id/image-name@sha256:digest" // The resource URL to analyze

	flag.StringVar(&projectID, "project", projectID, "The Google Cloud Platform project ID.")
	flag.StringVar(&instanceID, "resource_url", resourceURL, "The GCR resource to analyze.")
	flag.Parse()

	ctx := context.Background()

	// Get a Container Analysis Client.
	client, err := containeranalysis.NewGrafeasV1Beta1Client(ctx, projectID)
	if err != nil {
		log.Fatalf("Failed to create client: %v", err)
	}

	// Close client when done.
	defer client.Close()

	// Wait for analysis to complete.
	occ, err := pollDiscoveryOccurrenceFinished(ctx, client, resourceURL, projectID, discoveryProviderID, discoveryVulnerabilityNoteID)
	if err != nil {
		log.Errorf("Failed to get occurrence: %v", err)
	}
	analysisStatus := occ.GetDiscovered().GetDiscovered().AnalysisStatus
	log.Infof("Vulnerability analysis complete, status is %s", analysisStatus)
	if analysisStatus != discovery.Discovered_FINISHED_SUCCESS {
		log.Exitf("Failed to analyze image")
	}

	// Find any vulnerabilities for this resource.
	vulnOccs, err := findVulnerabilityOccurrencesForImage(ctx, client, resourceURL, projectID)
	if err != nil {
		log.Exitf("Failed to get vulnerability occurrences: %v", err)
	}
	log.Infof("Got %d vulnerabilities", len(vulnOccs))

	// [START containeranalysis_filter_vulnerability_occurrences]

	// Filter occurrence based on non-distribution specific CVSS severity rating.
	filteredOccs := filterOccurrences(vulnOccs, func(occ *grafeaspb.Occurrence) bool {
		s := occ.GetVulnerability().GetSeverity()
		return s == vulnerability.Severity_HIGH || s == vulnerability.Severity_CRITICAL
	})
	log.Infof("Got %d severity high or above vulnerabilities:", len(filteredOccs))
	for i, occ := range filteredOccs {
		log.Infof("Vulnerability %d:\n%+v", i+1, occ)
	}

	// [END containeranalysis_filter_vulnerability_occurrences]
}

// [START containeranalysis_poll_discovery_occurrence_finished]

// pollDiscoveryOccurrenceFinished returns a discovery occurrence for an image once that discovery occurrence is in a finished state.
func pollDiscoveryOccurrenceFinished(ctx context.Context, client *grafeaspb.GrafeasV1Beta1Client, resourceURL, projectID, providerProjectID, providerNoteID string) (*grafeaspb.Occurrence, error) {
	ticker := time.NewTicker(backoff)
	defer ticker.Stop()

	var occ *grafeaspb.Occurrence

	for {
		if occ == nil {
			// Find the specific discovery occurrence using list occurrence
			log.Infof("Querying for discovery occurrence")
			req := &grafeaspb.ListOccurrencesRequest{
				Parent: fmt.Sprintf("projects/%s", projectID),
				Filter: fmt.Sprintf("resourceUrl = %q noteProjectId = %q noteId = %q", resourceURL, providerProjectID, providerNoteID),
			}
			rep, err := client.ListOccurrences(ctx, req)
			if err != nil {
				log.Errorf("Error listing occurrences: %v", err)
				return nil, err
			}
			// Only one should ever be returned by ListOccurrences and the given filter.
			if len(rep.GetOccurrences()) > 0 {
				occ = rep.GetOccurrences()[0]
			}
		} else {
			// Query for the status of the discovery occurrence.
			log.Infof("Awaiting discovery occurrence terminal state, current state: %q", occ.GetDiscovered().GetDiscovered().AnalysisStatus)
			newOcc, err := client.GetOccurrence(ctx, &grafeaspb.GetOccurrenceRequest{Name: occ.GetName()})
			if err != nil {
				return nil, fmt.Errorf("error getting occurrence: %v", err)
			}
			occ = newOcc
		}

		if discoveryOccurrenceFinished(occ) {
			break
		}

		<-ticker.C // Wait to make next request.
	}

	return occ, nil
}

// discoveryOccurrenceFinished returns true if the analysis_status of a discovery occurrence is finished.
func discoveryOccurrenceFinished(occ *grafeaspb.Occurrence) bool {
	terminalStates := []discovery.Discovered_AnalysisStatus{
		discovery.Discovered_FINISHED_SUCCESS,
		discovery.Discovered_FINISHED_FAILED,
		discovery.Discovered_FINISHED_UNSUPPORTED,
	}

	for _, state := range terminalStates {
		if state == occ.GetDiscovered().GetDiscovered().GetAnalysisStatus() {
			return true
		}
	}

	return false
}

// [END containeranalysis_poll_discovery_occurrence_finished]

// [START containeranalysis_vulnerability_occurrences_for_image]

// findVulnerabilityOccurrencesForImage retrieves all vulnerability Occurrences associated with an image.
func findVulnerabilityOccurrencesForImage(ctx context.Context, client *containeranalysis.GrafeasV1Beta1Client, resourceURL, projectID string) ([]*grafeaspb.Occurrence, error) {
	var occs []*grafeaspb.Occurrence

	req := &grafeaspb.ListOccurrencesRequest{
		Parent: fmt.Sprintf("projects/%s", projectID),
		Filter: fmt.Sprintf("resourceUrl = %q kind = %q", resourceURL, "VULNERABILITY"),
	}

	it := client.ListOccurrences(ctx, req)
	for {
		occ, err := it.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}
		occs = append(occs, occ)
	}

	return occs, nil
}

// [END containeranalysis_vulnerability_occurrences_for_image]

// [START containeranalysis_filter_vulnerability_occurrences]

func filterOccurrences(occs []*grafeaspb.Occurrence, predicate func(*grafeaspb.Occurrence) bool) []*grafeaspb.Occurrence {
	var filteredOccs []*grafeaspb.Occurrence
	for _, occ := range occs {
		if predicate(occ) {
			filteredOccs = append(filteredOccs, occ)
		}
	}
	return filteredOccs
}

// [END containeranalysis_filter_vulnerability_occurrences]
